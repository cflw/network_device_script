import cflw代码库py.cflw网络地址 as 地址
import cflw代码库py.cflw字符串 as 字符串
from ..基础接口 import 操作
from ..基础接口 import 协议
from ..基础接口 import 访问控制列表 as 北向列表
from ..命令行接口 import 命令
from ..命令行接口 import 模式
from ..命令行接口 import 访问控制列表 as 南向列表
from ..华三命令行.常量 import *
from ..华三命令行 import 访问控制列表 as 旧列表
#===============================================================================
# 声明
#===============================================================================
C助手 = 旧列表.C助手
c基本 = "basic"
c高级 = "advanced"
c虚拟专用网实例 = "vpn-instance"
c网络协议4 = ""
c网络协议6 = "ipv6"
c源地址 = "source"
c源端口 = "source-port"
c目的地址 = "destination"
c目的端口 = "destination-port"
#===============================================================================
# 生成
#===============================================================================
def f生成名称_v7(a名称):	#序号不带"number"
	v类型 = type(a名称)
	if v类型 == int:
		return "%s" % (a名称,)
	v名称 = str(a名称)
	if v名称.isdigit():
		return "%s" % (v名称,)
	return "name %s" % (v名称,)
def f生成虚拟路由(a前置: str, a名称: str):
	if a名称:
		return "%s %s" % (a前置, a名称)
	else:
		return ""
def f生成规则_高级4(a序号: int, a规则: 北向列表.S规则):
	v命令 = 旧列表.f生成规则序号(a序号)
	v命令 += 旧列表.f生成动作(a规则.m动作)
	v命令 += 旧列表.f生成协议4(a规则.m协议)
	v命令 += f生成虚拟路由(c虚拟专用网实例, a规则.m源虚拟路由)
	v命令 += 旧列表.f生成地址4(c源地址, a规则.m源地址)
	v命令 += 旧列表.f生成端口(c源端口, a规则.m源端口)
	v命令 += f生成虚拟路由(c虚拟专用网实例, a规则.m目的虚拟路由)
	v命令 += 旧列表.f生成地址4(c目的地址, a规则.m目的地址)
	v命令 += 旧列表.f生成端口(c目的端口, a规则.m目的端口)
	return v命令
def f生成规则_高级6(a序号: int, a规则: 北向列表.S规则):
	v命令 = 旧列表.f生成规则序号(a序号)
	v命令 += 旧列表.f生成动作(a规则.m动作)
	v命令 += 旧列表.f生成协议6(a规则.m协议)
	v命令 += f生成虚拟路由(c虚拟专用网实例, a规则.m源虚拟路由)
	v命令 += 旧列表.f生成地址6(c源地址, a规则.m源地址)
	v命令 += 旧列表.f生成端口(c源端口, a规则.m源端口)
	v命令 += f生成虚拟路由(c虚拟专用网实例, a规则.m目的虚拟路由)
	v命令 += 旧列表.f生成地址6(c目的地址, a规则.m目的地址)
	v命令 += 旧列表.f生成端口(c目的端口, a规则.m目的端口)
	return v命令
#===============================================================================
# 解析
#===============================================================================
def f解析规则_高级4_v7(a规则: str):
	v解析器 = C规则解析器(a规则)
	v规则 = 北向列表.S规则()
	v规则.m序号 = v解析器.f序号()
	v规则.m动作 = v解析器.f动作()
	v规则.m协议 = v解析器.f协议()
	v规则.m源虚拟路由 = v解析器.f虚拟路由()
	v规则.m源地址 = v解析器.f地址4(c源地址)
	v规则.m源端口 = v解析器.f端口号(c源端口)
	v规则.m目的虚拟路由 = v解析器.f虚拟路由()
	v规则.m目的地址 = v解析器.f地址4(c目的地址)
	v规则.m目的端口 = v解析器.f端口号(c目的端口)
	return v规则
def f解析规则_高级6_v7(a规则: str):
	v解析器 = C规则解析器(a规则)
	v规则 = 北向列表.S规则()
	v规则.m序号 = v解析器.f序号()
	v规则.m动作 = v解析器.f动作()
	v规则.m协议 = v解析器.f协议()
	v规则.m源虚拟路由 = v解析器.f虚拟路由()
	v规则.m源地址 = v解析器.f地址6(c源地址)
	v规则.m源端口 = v解析器.f端口号(c源端口)
	v规则.m目的虚拟路由 = v解析器.f虚拟路由()
	v规则.m目的地址 = v解析器.f地址6(c目的地址)
	v规则.m目的端口 = v解析器.f端口号(c目的端口)
	return v规则
fc本地列表_基本4 = 旧列表.fc本地列表_基本4
def fc本地列表_高级4(a配置: str):
	return 北向列表.C列表(旧列表.fe规则0(a配置, f解析规则_高级4_v7))
fc本地列表_基本6 = 旧列表.fc本地列表_基本6
def fc本地列表_高级6(a配置: str):
	return 北向列表.C列表(旧列表.fe规则0(a配置, f解析规则_高级6_v7))
#===============================================================================
# 显示
#===============================================================================
class I列表显示_v7(旧列表.I列表显示):
	def fg显示命令(self, a序号 = None):
		v命令 = 命令.C命令("display acl")
		v命令 += self.c协议
		v命令 += f生成名称_v7(self.m名称)
		if a序号 != None:
			v命令 += "| include rule.%d.[dp]" % (a序号,)
		return v命令
class C基本4显示_v7(I列表显示_v7):
	c类型 = 旧列表.c基本
	c协议 = 旧列表.c网络协议4
	f解析规则 = staticmethod(旧列表.f解析规则_基本4)
class C高级4显示_v7(I列表显示_v7):
	c类型 = 旧列表.c高级
	c协议 = 旧列表.c网络协议4
	f解析规则 = staticmethod(f解析规则_高级4_v7)
class C基本6显示_v7(I列表显示_v7):
	c类型 = 旧列表.c基本
	c协议 = 旧列表.c网络协议6
	f解析规则 = staticmethod(旧列表.f解析规则_基本6)
class C高级6显示_v7(I列表显示_v7):
	c类型 = 旧列表.c高级
	c协议 = 旧列表.c网络协议6
	f解析规则 = staticmethod(f解析规则_高级6_v7)
#===============================================================================
# 配置
#===============================================================================
class I列表配置_v7(旧列表.I列表配置):
	"""acl 类型 访问列表号
	适用于: v7.1"""
	def fg进入命令(self):
		v命令 = 命令.C命令("acl")
		v命令 += self.c协议
		v命令 += self.c类型
		v命令 += f生成名称_v7(self.m名称)
		return v命令
class C基本4配置_v7(I列表配置_v7, C基本4显示_v7):
	c类型 = 旧列表.c基本
	c协议 = 旧列表.c网络协议4
	f生成规则 = staticmethod(旧列表.f生成规则_基本4)
class C高级4配置_v7(I列表配置_v7, C高级4显示_v7):
	"""适用于: 华三s5560x(v7.1.070), 华三s9810(v7.1.045)
		紫光s5200(v7.1.070), 紫光s5600(v7.1.070), 紫光s6600(v7.1.070), 紫光s8600x(v7.1.070)"""
	c类型 = 旧列表.c高级
	c协议 = 旧列表.c网络协议4
	f生成规则 = staticmethod(f生成规则_高级4)
class C基本6配置_v7(I列表配置_v7, C基本6显示_v7):
	c类型 = 旧列表.c基本
	c协议 = 旧列表.c网络协议6
	f生成规则 = staticmethod(旧列表.f生成规则_基本6)
class C高级6配置_v7(I列表配置_v7, C高级6显示_v7):
	c类型 = 旧列表.c高级
	c协议 = 旧列表.c网络协议6
	f生成规则 = staticmethod(f生成规则_高级6)
#===============================================================================
# 规则解析器
#===============================================================================
class C规则解析器:
	def __init__(self, a文本):
		self.m取词 = 字符串.C推进取词(a文本)
	def f动作(self):
		return self.m取词.f取词推进() == "permit"
	def f协议(self):
		return 南向列表.ca字符串到协议[self.m取词.f取词推进()]
	def f序号(self):
		self.m取词.f推进()
		v词 = self.m取词.f取词推进()
		return int(v词)
	def f虚拟路由(self):
		v关键字 = self.m取词.f取词()
		if v关键字 != "vpn-instance":
			return
		self.m取词.f推进()
		v词0 = self.m取词.f取词推进()
		return v词0
	def f地址4(self, a关键字: str):
		v关键字 = self.m取词.f取词()
		if v关键字 != a关键字:
			return
		self.m取词.f推进()
		v词0 = self.m取词.f取词推进()
		if v词0 == "any":
			return None
		v词1 = self.m取词.f取词推进()
		if v词1.isdigit():
			v前缀长度 = int(v词1)
			if v前缀长度 == 0:	#主机地址
				return 地址.S网络地址4.fc主机地址字符串(v词0)
			else:	#真前缀长度
				return 地址.S网络地址4.fc地址前缀长度(v词0, v前缀长度)
		elif v词1.count(".") == 3:	#通配符
			v掩码 = 地址.S网络地址4.c全f - 地址.S网络地址4.f地址字符串转整数(v词1)
			return 地址.S网络地址4.fc地址掩码(v词0, v掩码)
		else:	#不存在的情况
			raise RuntimeError("无法解析的配置")
	def f地址6(self, a关键字: str):
		v关键字 = self.m取词.f取词()
		if not v关键字 != a关键字:
			return
		self.m取词.f推进()
		v词0 = self.m取词.f取词推进()
		if v词0 == "any":
			return None
		return 地址.S网络地址6.fc自动(v词0)
	def f端口号(self, a关键字: str):
		v关键字 = self.m取词.f取词()
		if v关键字 != a关键字:
			return
		self.m取词.f推进()
		v词 = self.m取词.f取词推进()
		vf端口号 = C规则解析器.ca端口号运算函数[v词]
		return vf端口号(self)
	def f端口号_大于(self):
		return 北向列表.S端口号.fc大于(协议.f解析端口号(self.m取词.f取词推进()))
	def f端口号_小于(self):
		return 北向列表.S端口号.fc小于(协议.f解析端口号(self.m取词.f取词推进()))
	def f端口号_等于(self):
		return 北向列表.S端口号.fc等于(协议.f解析端口号(self.m取词.f取词推进()))
	def f端口号_不等于(self):
		return 北向列表.S端口号.fc不等于(协议.f解析端口号(self.m取词.f取词推进()))
	def f端口号_范围(self):
		v词1 = self.m取词.f取词推进()
		v词2 = self.m取词.f取词推进()
		return 北向列表.S端口号.fc范围(range(int(v词1), int(v词2) + 1))
	ca端口号运算函数 = {
		"eq": f端口号_等于,
		"neq": f端口号_不等于,
		"gt": f端口号_大于,
		"lt": f端口号_小于,
		"range": f端口号_范围,
	}